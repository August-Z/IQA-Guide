# IQA 语句结构

> IQA-Script，上文我们说到演绘脚本最后会交由 JavaScript 来执行，所以其实我们编写的演出脚本，都是具有**结构体**的，同时其含有不同的作用，<font color=#ea6a6e>**想编写出色的演出脚本，理解语句结构是必不可少的**</font>。

### 按行分割
> IQA 演出脚本的语句通常由一行来界定有效的指令，所以如果使用指令则一定要严格按照行为单位，不可多个指令写入在一行中。

### 拆分一句 IQA 指令
这是一句图层动画指令，用于操作图层进行运动：
```sql
@avg.animation BG1 x=10 time=250 repeat=10 yoyo
```
在解析的过程中时，每一句演出脚本都会按照下方的形式转化为**结构体**：
![一句图层动画指令的拆分图](https://new-image.iqing.com/play/5eb7c9f6-5fe6-45f9-9220-87b5d3a5c1e2.png)  
**<font color=ea6a6e size=48>注：props 和 attr 的书写位置只需在 target 右侧即可，两者没有前后顺序的要求</font>**  

### 指令由哪些部分构成
一个有效的 IQA 指令暴露给开发者一共分5个部分：

结构名|含义|特征
:--:|:--:|:--:
RunSymbol|运行符（同步、异步、注释）|可控制演绘运行流程
APC|开发指令|详见 [开发指令](../指令大全/README.md)
Target|对象，APC 操作的目标|紧接 APC 右侧
Attr|标签，通常是赋予 APC 特殊功能|特殊的属性
Props|参数，对 APC 的运行的说明|左右值使用 "=" 连接



```ruby
* 语句结构
[RunSymbol] [APC] {Target} (Attr) (Props)

* 树状结构
├── RunSymbol
│   ├── APC <-- Target
│   ├ - Attr
│   │   ├ - Attr 1   
│   │   ├ - Attr 2
│   │   ├ - .......
│   ├ - Props
│   │   ├ - Props 1   
│   │   ├ - Props 2
│   │   ├ - .......
```

### 解析失败的指令会如何？
让我们先来看一段简易的段落
```sql
不知不觉中，窗外下起了小雨，细密的水珠勾起一道道水痕，在老旧的玻璃窗上延伸。[p]
@avg.create BG1
我盯着窗外愈来愈模糊的景色，不由得发出叹息。[x][p]
```
在引擎首步解析的时候，首先会尝试指令化，这时 [p] 这类语法糖就会被进行转译：
```sql
不知不觉中，窗外下起了小雨，细密的水珠勾起一道道水痕，在老旧的玻璃窗上延伸。
#p
@avg.create BG1
我盯着窗外愈来愈模糊的景色，不由得发出叹息。
#x
#p
```
在引擎指令化转译后，会尝试获取指令集，`#x` 因为不是一个有效的指令。  
**<font color=orange>所以这里它被字符串化了..会原封不动地显示在演绘屏幕上哟！</font>**
```text
{ 第一段文本... }
{ 待点击后清屏，此时演绘停顿 }
{ 创建名为 BG1 图层 }
{ 第二段文本... }
#x
{ 待点击后清屏，此时演绘停顿 }
```
> 在这个过程中还有一些其他的语法抽离，可以使用一些高阶用法（如变量与运算），在后续的具体的介绍中会详细说明




